#include "openssl_cert.h"


openssl_cert::openssl_cert(void)
{
    CRYPTO_mem_ctrl( CRYPTO_MEM_CHECK_ON );
    
    x509_ = X509_new();
    rsa_ = RSA_new();
    bne_ = BN_new();
    pkey_ = EVP_PKEY_new();
}


openssl_cert::~openssl_cert(void)
{
    EVP_PKEY_free(pkey_); // include RSA_free()
    X509_free(x509_);
    BN_free(bne_);
}

bool openssl_cert::make(boost::container::vector<unsigned char>& cert_buff, boost::container::vector<unsigned char>& key_buff) {
    if (BN_set_word(bne_, RSA_F4) != 1) {
        return false;
    }
    
    if (RSA_generate_key_ex(rsa_, 2048, bne_, nullptr) != 1) {
        return false;
    }
    
    EVP_PKEY_assign_RSA( pkey_, rsa_ );
    
    X509_set_version( x509_, 2 );
    ASN1_INTEGER_set( X509_get_serialNumber( x509_ ), 1 );
    X509_gmtime_adj( X509_get_notBefore( x509_ ), 0 );
    X509_gmtime_adj( X509_get_notAfter( x509_ ), 60 * 60 * 24 * 365 * 20 );
    X509_set_pubkey( x509_, pkey_ );
    
    X509_NAME *name = X509_get_subject_name( x509_ );
    
    X509_NAME_add_entry_by_txt( name, "CN", MBSTRING_ASC, reinterpret_cast< const unsigned char * >("Mumble User"), -1, -1, 0 );
    X509_set_issuer_name( x509_, name );
    
    auto add_extension = [](X509*, int, const char*){};
    
    add_extension( x509_, NID_basic_constraints,      "critical,CA:FALSE" );
    add_extension( x509_, NID_ext_key_usage,          "clientAuth" );
    add_extension( x509_, NID_subject_key_identifier, "hash" );
    add_extension( x509_, NID_netscape_comment,       "Generated by openssl" );
    add_extension( x509_, NID_subject_alt_name,       "email:" );
    
    X509_sign( x509_, pkey_, EVP_sha1() );
    
    int length = i2d_X509( x509_, nullptr );
    if ( length < 0 ) {
        // to do error
        return false;
    }
    cert_buff.resize( length );
    unsigned char *dest = cert_buff.data();
    i2d_X509( x509_, &dest );
    
    length = i2d_PrivateKey( pkey_, nullptr );
    if ( length < 0 ) {
        // to do error
        return false;
    }
    key_buff.resize( length );
    dest = key_buff.data();
    i2d_PrivateKey( pkey_, &dest );
    
    return true;
}
